/**
 * Insurance & Eligibility Server Actions for Step 2
 * OrbiPax Community Mental Health System
 *
 * Server actions that orchestrate auth, multi-tenant isolation,
 * compose dependencies (DI), and delegate to Application layer for business logic
 *
 * SoC: Auth/session + dependency composition - NO validation, NO business logic
 * Pattern: Guards → DI → Use Cases → Generic Response
 */

'use server'

import { resolveUserAndOrg } from '@/shared/lib/current-user.server'
import {
  loadInsuranceEligibility,
  saveInsuranceEligibility,
  updateInsuranceEligibility,
  type InsuranceEligibilityInputDTO,
  type InsuranceEligibilityOutputDTO,
  InsuranceEligibilityErrorCodes
} from '@/modules/intake/application/step2'

// Import factory from Infrastructure layer for dependency injection
import { createInsuranceEligibilityRepository } from '@/modules/intake/infrastructure/factories/insurance-eligibility.factory'

/**
 * Action Response type - standardized for all actions
 * JSON-serializable contract for UI
 */
type ActionResponse<T = void> = {
  ok: boolean
  data?: T
  error?: {
    code: string
    message?: string // Generic messages only, no PII
  }
}

/**
 * Load Insurance & Eligibility Action
 *
 * Retrieves insurance & eligibility data for the current session
 * Enforces auth and multi-tenant isolation
 *
 * @returns Insurance & eligibility data or error response
 */
export async function loadInsuranceEligibilityAction(): Promise<ActionResponse<InsuranceEligibilityOutputDTO>> {
  try {
    // Auth guard - get user and organization
    let userId: string
    let organizationId: string

    try {
      const auth = await resolveUserAndOrg()
      userId = auth.userId
      organizationId = auth.organizationId
    } catch (error) {
      // Auth/session failed - return generic error
      return {
        ok: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Request failed'
        }
      }
    }

    // Validate organization context
    if (!organizationId) {
      return {
        ok: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Request failed'
        }
      }
    }

    // TODO: Get actual session ID from context/params
    // For now using a deterministic session ID based on user
    const sessionId = `session_${userId}_intake`

    // Create repository instance using factory (skeleton for now)
    const repository = createInsuranceEligibilityRepository()

    // Compose dependencies and delegate to Application layer
    const result = await loadInsuranceEligibility(repository, sessionId, organizationId)

    // Map Application response to Action response
    if (!result.ok) {
      // Always return generic error messages
      return {
        ok: false,
        error: {
          code: result.error?.code || 'UNKNOWN',
          message: 'Request failed'
        }
      }
    }

    return {
      ok: true,
      data: result.data
    }
  } catch (error) {
    // Unexpected error - return generic error
    return {
      ok: false,
      error: {
        code: 'UNKNOWN',
        message: 'Request failed'
      }
    }
  }
}

/**
 * Upsert Insurance & Eligibility Action
 *
 * Creates or updates insurance & eligibility data for the current session
 * Enforces auth and multi-tenant isolation
 * Uses generic parameter type for safety
 *
 * @param input - Insurance & eligibility data to save (unknown type for safety)
 * @returns Success response or error
 */
export async function upsertInsuranceEligibilityAction(
  input: unknown
): Promise<ActionResponse<{ sessionId: string }>> {
  try {
    // Auth guard - get user and organization
    let userId: string
    let organizationId: string

    try {
      const auth = await resolveUserAndOrg()
      userId = auth.userId
      organizationId = auth.organizationId
    } catch (error) {
      // Auth/session failed - return generic error
      return {
        ok: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Request failed'
        }
      }
    }

    // Validate organization context
    if (!organizationId) {
      return {
        ok: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Request failed'
        }
      }
    }

    // TODO: Get actual session ID from context/params
    // For now using a deterministic session ID based on user
    const sessionId = `session_${userId}_intake`

    // Cast input to expected DTO type (validation happens in Application layer)
    const typedInput = input as InsuranceEligibilityInputDTO

    // Create repository instance using factory (skeleton for now)
    const repository = createInsuranceEligibilityRepository()

    // Compose dependencies and delegate to Application layer
    // Using saveInsuranceEligibility which handles both create and update
    const result = await saveInsuranceEligibility(repository, typedInput, sessionId, organizationId)

    // Map Application response to Action response
    if (!result.ok) {
      // Always return generic error messages
      return {
        ok: false,
        error: {
          code: result.error?.code || 'UNKNOWN',
          message: 'Request failed'
        }
      }
    }

    return {
      ok: true,
      data: result.data
    }
  } catch (error) {
    // Unexpected error - return generic error
    return {
      ok: false,
      error: {
        code: 'UNKNOWN',
        message: 'Request failed'
      }
    }
  }
}